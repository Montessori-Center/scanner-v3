# Eternal Max Analyzer — Roadmap MVP → v1.0

Коротко и честно: идея сильная, каркас уже рабочий, но до «инструмента для чужих репозиториев» пока не дотягивает. 
Главные риски — хрупкие парсеры на grep/awk, ручная сборка JSON и отсутствие формализованной схемы данных/тестов.

Диагноз по ключевым осям (по 10-балльной)

    Архитектура — 7/10. 
        Модульный bash, единое ядро (core/*), понятные модули (modules/*). 
        Плюсы: простота, легко расширять.
        Минусы: нет контрактов/интерфейсов модулей и единого «реестра» плагинов.

    Надёжность — 5/10. 
        После фиксов стартует стабильно, но JSON собирается руками (риск запятых/кавычек), ошибки CLI утилит местами не поднимаются наверх. 
        Нужны строгие проверки и единый код возврата.

    Портабельность — 6/10. 
        Есть GNU-зависимости (date -Iseconds и т.п.), на macOS/BusyBox часть опций отвалится. 
        Мы ввели POSIX-временную функцию, но это надо довести до всех мест.

    Производительность — 6/10. 
        Для средних репо ок. На монорепо/гигантах нужен кэш, инкрементальные прогоны и более агрессивные исключения.

    Developer Experience — 5/10. 
        Стало лучше (install/uninstall, Makefile), но не хватает «analyzer doctor», нормального --help, примеров сценариев и читаемого README с диаграммой потока.

    Данные/БД — 4/10. 
        Нет официального DDL/миграций, нет версии схемы, запись частично закомментирована.
        Это сейчас «best effort», а не гарантированный контракт.

    Безопасность — 6/10.
        Цитирование улучшено, но: передача пароля MySQL через аргументы светится в ps; нет маскирования секретов в логах; eval/SQL-паттерны грубоваты.

    Тестирование — 3/10. 
        Нет наборов фикстур, «золотых» эталонов JSON и CI. Любая правка может незаметно сломать метрики.

    Где тонко и сломается первым
        Репо с пробелами/юникодом в путях, бинарниками и очень длинными строками (нужны -print0/read -d '' повсюду).
        Монорепы с десятками node_modules/vendor (нужны строгие exclude и кэш).
        Не-UTF-8 файлы (ломают grep/JSON).
        Символические ссылки/циклы (нужно «обрезать» и/или ограничить глубину).
        Парсинг SQL/PHP по regex, где ложно-положительные/отрицательные срабатывания неизбежны.

    Что доделать до полноценного MVP (приоритет сверху)
        1. Единый контракт модулей.
        Спецификация: входы (ENV/флаги), выход — строго валидный JSON со схемой version, timestamp, metrics, items[]. Выход каждого модуля — через один хелпер emit_json.

        2. JSON-схема + валидация.
        Определить schema/*.json (inputs/outputs/db_ops и т.д.) и валидировать jq/ajv (если есть). Ошибка схемы = красный выход.

        3. Инкрементальные прогоны.
        Индекс {файл → hash, mtime, размер}; сканировать только изменённые. Команда: --cache .em-cache и --since last.

        4. Доктор и диагностика.
        analyzer.sh --doctor проверяет bash/find/grep/sed/awk/jq/mysql, права, .env, подключение к БД, и печатает рекомендации.

        5. DDL + миграции (с note).
        schema/analysis.sql + migrations/ c версией схемы. Установщик поддерживает --setup-db. Индексы по project_id, module, ts.

        6. Чистый вывод и логирование.
        Уровни: error/warn/info/debug, цвет/безцвет, --quiet. Обязательная запись stderr утилит в файл ошибок.

        7. Набор тест-фикстур и CI.
        Пять мини-репозиториев (WordPress, Laravel, Express, Vue/React, «грязный Legacy PHP») + «золотые» JSON. GitHub Actions гоняет make check && make test.

        8. Exclude/ignore 2.0.
        Поддержка .gitignore-подобных паттернов и пользовательского --extra-exclude. Документация синтаксиса.


        Рекомендованные точечные правки
            Везде заменить date -Iseconds на наш iso_now (POSIX).
            Вынести сборку JSON в core/utils.sh: json_begin/json_add/json_end (минимум риска лишних запятых).
            mysql: использовать MYSQL_PWD или ~/.my.cnf (ограничить права 600), в логах звёздочками маскировать DB_PASS.
            Повсеместно set -Eeuo pipefail, trap с нормальным сообщением.
            В сканере — find -print0 | while IFS= read -r -d '' f; do …; done и тотальная кавычка путей.
            Добавить analyzer --dry-run с печатью плана работ.


        Итоговая оценка (без реверансов)
            Текущий статус: «рабочий прототип для своих задач», который после наших фиксов запускается и приносит пользу.
            Главная боль: надёжность результатов и воспроизводимость (схема/тесты/CI).
            Порог вхождения: низкий (bash), но поддерживаемость на дистанции средняя — имеет смысл держать возможность подложить Python-бэкенд парсеров под теми же контрактами модулей.



ETERNAL MAX ANALYZER — ROADMAP MVP → V1.0

    > Цель: довести библиотеку до воспроизводимого MVP, а затем до v1.0, где результаты стабильны, измеряемы и валидируются схемами. 
      Без косметики — только то, что повышает надёжность и даёт контроль качества.

---

## Гейт 0 — «Заработает ли прямо сейчас?» (baseline)
**Критерий приёмки:** после шагов ниже `./analyzer.sh --all` отрабатывает без фатальных ошибок, создаёт валидный `output/*/data/*.json`, README/--help понятны.

- [ ] Запустить `bootstrap_layout.sh` и привести дерево к `core/`, `modules/`, `parsers/`, `config/`, `tests/`.
- [ ] Обновить `modules/dataflow.sh` (fixed) и `modules/workflow.sh` (fixed) — версии из канваса «Путь развертывания v2».
- [ ] Привести `config/exclude.conf` (переименовать из `.txt`, удалить одиночную строку `sed`).
- [ ] `make check` → «Syntax OK / Deps OK».
- [ ] Smoke‑тест: `./analyzer.sh <project> --all --parallel --debug` → success‑логи, валидные JSON.

**Go/No‑Go:** если всё зелёное — движемся к MVP; иначе правим конкретный модуль до зелёного статуса.

---

## Фаза 1 — Контракт модулей + единые JSON‑утилиты
**Задача:** убрать «ручной JSON» и разнобой в интерфейсах модулей.

- [ ] Спецификация модуля `MODULE.md`: входы (ENV/flags), выходной JSON (обязательные поля: `generator`, `version`, `timestamp`, `metrics`, `items[]`).
- [ ] В `core/utils.sh` добавить: `iso_now()`, `json_escape()`, `json_begin()`, `json_add_item()`, `json_end()`.
- [ ] Рефактор 10 модулей на эти хелперы; убрать риск лишних запятых.
- [ ] Единый `emit_json <outfile>` — атомарная запись + проверка размера.

**Критерий:** любой модуль при `bash -c 'source core/utils.sh; ...'` выдаёт валидный JSON без пост‑правок.

---

## Фаза 2 — JSON‑схемы и валидация
**Задача:** формализовать формат результатов и ловить дрейф данных.

- [ ] Каталог `schema/` с `*.schema.json` для каждого модуля.
- [ ] Включить `jq`/`ajv` (если доступен) в `validate_json()`. Падать при несоответствии схеме.
- [ ] Целевой Make‑таргет: `make validate` → прогон схем по всем последним артефактам.

**Критерий:** `make validate` зелёный на smoke‑фикстурах.

---

## Фаза 3 — Портабельность и надёжность оболочки
**Задача:** выдерживать GNU/macOS/BusyBox, странные пути и двоичные файлы.

- [ ] Везде заменить `date -Iseconds` → `iso_now` (POSIX формат `YYYY-MM-DDTHH:MM:SSZ`).
- [ ] Тотальное экранирование путей; сканер: `find -print0 | while IFS= read -r -d '' f; do ...; done`.
- [ ] Обработка не‑UTF‑8: `LC_ALL=C` для grep/awk в чувствительных местах.
- [ ] Трап/флаги: `set -Eeuo pipefail` + `trap` с печатью модуля и строки.

**Критерий:** `make check` и smoke на macOS/Alpine/Ubuntu (минимальный стенд) — без падений.

---

## Фаза 4 — Data layer: DDL + миграции (с обязательным `note`)
**Задача:** контракт БД + автоматизация установки.

- [ ] `schema/analysis.sql` с явным описанием `em_analysis_results`, `em_analysis_details` (индексы, внешние ключи, `note` в конце таблиц).
- [ ] Каталог `migrations/` + номер версии схемы в `.env` (`SCHEMA_VERSION`).
- [ ] `install.sh --setup-db` обновлён под порт 3305, применяет `schema/analysis.sql`.

**Критерий:** чистая установка БД «с нуля» + успешная запись результатов при `--use-db`.

---

## Фаза 5 — Инкрементальные прогоны и кэш
**Задача:** ускорить анализ на больших репозиториях.

- [ ] Кэш‑индекс: `{path, size, mtime, sha1}` в `.em-cache/index.tsv`.
- [ ] Флаги: `--cache-dir`, `--since=<timestamp>`, `--changed-only`.
- [ ] Сканер пропускает неизменённые файлы; модули читают список изменённых.

**Критерий:** повторный прогон на том же проекте быстрее ≥ X раз при неизменённых файлах (метрика фиксируется в логах).

---

## Фаза 6 — Doctor + UX CLI
**Задача:** самодиагностика и дружелюбная помощь пользователю.

- [ ] `analyzer.sh --doctor` проверяет: версии утилит, `.env`, доступ к БД, права на `output/`, наличие `jq/mysql`.
- [ ] Полноценный `--help` с примерами рецептов.
- [ ] README с диаграммой потока (скан → модули → отчёт/БД) и примерами команд.

**Критерий:** `--doctor` печатает actionable‑советы, README понятно пройти «с нуля».

---

## Фаза 7 — Тест‑фикстуры, «золотые» файлы и CI
**Задача:** защищаемся от регрессий.

- [ ] `tests/fixtures/` (5 мини‑реп): WordPress, Laravel, Express, React/Vue, «Legacy PHP».
- [ ] «Золотые» JSON‑снимки в `tests/golden/` + скрипт сравнения с допуском по шуму.
- [ ] GitHub Actions: `make check && make test && make validate` на push/PR.

**Критерий:** PR без зелёного CI не мёржится.

---

## Фаза 8 — Exclude/ignore 2.0
**Задача:** гибкое исключение мусорных путей.

- [ ] Поддержка пользовательских паттернов и совместимости с `.gitignore`‑подобным синтаксисом.
- [ ] Флаг `--extra-exclude <file>` и переменная окружения `EM_EXCLUDE_FILE`.

**Критерий:** крупные монорепы анализируются без захода в `node_modules/`, `vendor/`, `dist/`, артефакты сборки.

---

## Фаза 9 — (Опционально) тонкие парсеры на Python под тем же контрактом
**Задача:** сохранить bash‑оркестрацию, но ускорить/улучшить распознавание.

- [ ] `parsers/py/` с CLI‑скриптами, выдающими тот же JSON‑контракт.
- [ ] Флаг `--parsers=py|sh|auto`.

**Критерий:** переключение режимов не меняет структуру результатов.

---

## Набор smoke‑тестов (быстрые проверки)
- [ ] `./analyzer.sh . --essential --debug` → код возврата 0, `output/.../data/` непуст.
- [ ] `jq . output/.../data/*.json` → валидный JSON.
- [ ] `./analyzer.sh . --all --parallel --use-db` → запись в БД ок (при наличии схемы).
- [ ] `eternal-max --help` работает из `$PATH`.

---

## Релиз v1.0 — критерии «готово»
- [ ] Все фазы 1–8 закрыты зелёным, CI зелёный.
- [ ] README → любой разработчик повторяет установку и прогон без личной помощи.
- [ ] На 3 реальных репозиториях (PHP‑legacy, Laravel, JS‑SPA) результаты устойчивы, прогон ≤ разумного времени, баг‑репорты пустые.

---

## Примечания по безопасности
- [ ] Пароли к MySQL не светятся в `ps` (используем `MYSQL_PWD` или `~/.my.cnf`).
- [ ] Логи маскируют секреты (`****`).
- [ ] Все `exec`/`eval` паттерны ищутся и учитываются в метриках.

---

### Что дальше
- На базе этого плана формируем задачи (issue‑лист) и идём по чек‑боксам. После закрытия Гейта 0 делаем короткий отчёт и переключаемся на Фазу 1.

